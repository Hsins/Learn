(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{548:function(e,a,s){"use strict";s.r(a);var t=s(8),r=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"creating-a-production-grade-workflow"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#creating-a-production-grade-workflow"}},[e._v("#")]),e._v(" Creating a Production-Grade Workflow")]),e._v(" "),s("h2",{attrs:{id:"development-workflow"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#development-workflow"}},[e._v("#")]),e._v(" Development Workflow")]),e._v(" "),s("p",[e._v("一個常見的開發流程會涉及到三個階段，也就是開發（develop）、測試（test）和佈署（deploy）。舉例來說，開發團隊會先從主分支（master branch）創建一個分支並進行開發，開發完成後會推送（push）到代碼託管平台如 GitHub 上，並創建一個 PR（Pull Request）等待 Merge 進入主分支。在這一個階段，代碼會先被推送到持續集成（Continuous Integration, CI）平台運行測試，如果沒有問題則會將分支進行 Merge 後再次運行測試，一切都完成並且沒有問題就會佈署到雲端服務器。")]),e._v(" "),s("h2",{attrs:{id:"create-the-dev-dockerfile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#create-the-dev-dockerfile"}},[e._v("#")]),e._v(" Create the Dev Dockerfile")]),e._v(" "),s("p",[e._v("為了區別開發環境（Development Environment）與正式環境（Production Environment），我們創建後綴為 "),s("code",[e._v(".dev")]),e._v(" 的 "),s("code",[e._v("Dockerfile.dev")]),e._v(" 來與之區別。但在創建 Docker 映像時，需要加上 "),s("code",[e._v("-f")]),e._v(" 參數來指定設定檔：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ docker build -f Dockerfile.dev "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(".")]),e._v("\n")])])]),s("h2",{attrs:{id:"docker-volumes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-volumes"}},[e._v("#")]),e._v(" Docker Volumes")]),e._v(" "),s("p",[e._v("在前面的內容曾經提到，運行容器中的狀態會是創建映像時的快照，因此如果修改了檔案內容，必須重新建構 Docker 映像。但實際開發時，我們不可能一有修改就重新創建映像，因此需要把資料夾掛載到容器中，而非單純的複製，這時就必須使用 Docker Volume 了。在命令行中使用 "),s("code",[e._v("-v")]),e._v(" 參數如下，將容器外當前位置 "),s("code",[e._v("${pwd}")]),e._v(" 映射到 "),s("code",[e._v("/app")]),e._v("：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# docker run -p <LOCAL_PORT>:<DOCKER_PORT> -v <BOOKMARK> -v <LOCAL_FOLDER>:<DOCKER_FOLDER> <IMAGE_ID>")]),e._v("\n$ docker run -p "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("3000")]),e._v(":3000 -v /app/node_modules -v "),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$(")]),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("pwd")]),s("span",{pre:!0,attrs:{class:"token variable"}},[e._v(")")])]),e._v(":/app "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("IMAGE_ID"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n")])])]),s("h2",{attrs:{id:"use-docker-volumes-with-docker-compose"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#use-docker-volumes-with-docker-compose"}},[e._v("#")]),e._v(" Use Docker Volumes with Docker Compose")]),e._v(" "),s("p",[e._v("我們可以使用 Docker Compose 來創建容器，並把 Docker Volume 的相關設定寫在 "),s("code",[e._v("docker-compose.yaml")]),e._v(" 中，避免每次運行容器時都需要打一串很長的命令：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("version: '3'\nservices:\n  web:\n    build:\n      context: .\n      dockerfile: Dockerfile.dev\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - /app/node_modules\n      - .:/app\n")])])]),s("h2",{attrs:{id:"docker-compose-for-running-tests"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-compose-for-running-tests"}},[e._v("#")]),e._v(" Docker Compose for Running Tests")]),e._v(" "),s("p",[e._v("直接使用 Docker Volume 掛載到容器中，我們可以很簡單地進行測試。除此之外，也能夠另外創建一個容器負責測試的部份：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('version: \'3\'\nservices:\n  web:\n    build:\n      context: .\n      dockerfile: Dockerfile.dev\n    ports:\n      - "3000:3000"\n    volumes:\n      - /app/node_modules\n      - .:/app\n  test:\n    build:\n      context: .\n      dockerfile: Dockerfile.dev\n    volumes:\n      - /app/node_modules\n      - .:/app\n    command: ["npm", "run", "test"]\n')])])]),s("h2",{attrs:{id:"production-container"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#production-container"}},[e._v("#")]),e._v(" Production Container")]),e._v(" "),s("p",[e._v("在最後的正式環境中，我們還需要使用 Nginx 來作為網頁伺服器，來處理反向代理、負載平衡器和 HTTP 快取。創建 "),s("code",[e._v("Dockerfile")]),e._v(" 如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("FROM node:alpine as builder\n\nWORKDIR '/app'\n\nCOPY package.json .\nRUN npm install\nCOPY . .\nRUN npm run build\n\nFROM nginx\nCOPY --from=builder /app/build /usr/share/nginx/html\n")])])]),s("p",[e._v("最後構建映像並運行容器：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# build production container")]),e._v("\n$ docker build "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(".")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# run container")]),e._v("\n$ docker run -p "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("8080")]),e._v(":80 "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("IMAGE_ID"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);